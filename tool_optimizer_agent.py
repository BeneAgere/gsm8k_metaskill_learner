

def create_two_step_virtual_tool(fn1, fn2):
    """
    Creates a new callable that composes fn1 and fn2 in a two-step sequence.
    By default, it expects three parameters: (a, b, c).
      1) Step 1: intermediate = fn1(a, b)
      2) Step 2: final = fn2(intermediate, c)
    Returns final.
    """

    def composed_tool(a, b, c):
        intermediate = fn1(a, b)
        return fn2(intermediate, c)

    return composed_tool

def update_tool_stats(
    tool_stats: dict,
    pair_stats: dict,
    used_tools: list[str],
    problem_solved: bool
) -> None:
    """
    Updates two separate dictionaries:
      1) tool_stats: records success/fail counts for each individual tool_name
      2) pair_stats: records success/fail counts for each adjacent pair (toolA, toolB)

    :param tool_stats: dict where keys are tool_name strings 
                       and values are {"success_count": int, "fail_count": int}
    :param pair_stats: dict where keys are (tool_nameA, tool_nameB) tuples
                       and values are {"success_count": int, "fail_count": int}
    :param used_tools: list of strings naming each tool that was invoked in sequence
    :param problem_solved: bool indicating if the final solution was correct or not
    :return: None; the dictionaries are updated in place.
    """
    outcome_key = "success_count" if problem_solved else "fail_count"

    # 1) Update individual tool stats
    for tool_name in used_tools:
        if tool_name not in tool_stats:
            tool_stats[tool_name] = {"success_count": 0, "fail_count": 0}
        tool_stats[tool_name][outcome_key] += 1

    # 2) Update adjacent pair stats
    for i in range(len(used_tools) - 1):
        pair = (used_tools[i], used_tools[i+1])
        if pair not in pair_stats:
            pair_stats[pair] = {"success_count": 0, "fail_count": 0}
        pair_stats[pair][outcome_key] += 1
    print(pair_stats)
    return tool_stats, pair_stats



def maybe_create_virtual_tools_from_pairs(pair_stats: dict, tools, client, model_name: str,
                                            success_threshold: float = 0.7, min_tries: int = 5) -> list:
    """
    Scans each (toolA, toolB) entry in pair_stats. If its success ratio exceeds
    success_threshold and total tries >= min_tries, then a new two-step tool is created.
    The new virtual tool's __doc__ is generated by prompting the LLM with the doc strings
    of the two constituent tools.
    """
    new_virtual_tools = []
    for pair, stats in pair_stats.items():
        # Skip if a virtual tool is already created or if one tool is "submit_answer"
        if stats.get("virtual_tool") is not None:
            continue
        if pair[0] == 'submit_answer' or pair[1] == 'submit_answer':
            continue
        success_count = stats.get("success_count", 0)
        fail_count = stats.get("fail_count", 0)
        total_tries = success_count + fail_count
        if total_tries < min_tries:
            continue
        ratio = success_count / total_tries if total_tries > 0 else 0.0
        if ratio >= success_threshold:
            try:
                toolA_name, toolB_name = pair
                if toolA_name not in tools or toolB_name not in tools:
                    continue
                fn1 = tools[toolA_name]
                fn2 = tools[toolB_name]
                new_fn = create_two_step_virtual_tool(fn1, fn2)
                
                # Prepare messages using the __doc__ attributes of the two functions.
                messages = [
                    {
                        "role": "system",
                        "content": "You are an expert technical writer, skilled in writing concise and informative API documentation."
                    },
                    {
                        "role": "user",
                        "content": (
                            f"Write a detailed docstring for a new virtual tool created by combining two functions.\n\n"
                            f"Function 1: {fn1.__name__}\n"
                            f"Description: {fn1.__doc__}\n\n"
                            f"Function 2: {fn2.__name__}\n"
                            f"Description: {fn2.__doc__}\n\n"
                            "The new virtual tool takes three parameters (a, b, c) and operates in two steps:\n"
                            "   Step 1: It calls Function 1 with (a, b) to calculate an intermediate value.\n"
                            "   Step 2: It passes the intermediate value together with c to Function 2 to produce the final result.\n\n"
                            "Please produce a docstring that explains the purpose, parameters, workflow, and provide an example usage if possible."
                        )
                    }
                ]
                # Request the LLM to generate the docstring.
                response = client.chat.completions.create(model=model_name, messages=messages)
                new_description = response.choices[0].message.content
                print(new_description)
                new_fn.__doc__ = new_description

                print("CREATED NEW VIRTUAL TOOL: {} from {} and {}".format(new_fn, toolA_name, toolB_name))
                stats["virtual_tool"] = new_fn  # store the new virtual tool
                new_virtual_tools.append(new_fn)
            except Exception as e:
                print("Tool creation failed for {} and {}: {}".format(pair[0], pair[1], e))
    return new_virtual_tools